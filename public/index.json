[
{
	"uri": "/introduction-to-r/",
	"title": "Introduction to R",
	"tags": [],
	"description": "",
	"content": " Introduction to R Setting up your working environment in R studio\n"
},
{
	"uri": "/introduction-to-r/01_r-studio-and-the-coding-environment/",
	"title": "R Studio &amp; Coding Environment",
	"tags": [],
	"description": "",
	"content": "Introduction\rThis module will provide an introduction into the R statisitical environment, going through the basics of data analysis and graphing for publication quality results.\rBy the end of this module, you should be able to:\n\rUnderstand and use the R studio working environment\rImport and manipulate data files\rUndertake linear (ANOVA, regression) and generalised linear (logistic regression) models and associated assumptions/comparisons\rUndertake basic multivariate techniques (PCA, MDS)\rConstruct bar plots and scatterplots in ggplot\r\rWhat is R?\rR is a language and environment for statistical computing and graphics. R is free/open source software and as a result, has a community of dedicated statisticans, coders and developers increasing the capabilities and usability of the platform.\rR primarily runs as a command-line program.\nThis is a big entry barrier to many starting to learn R, so most people have turned to “R Studio”.\nBase R\n\r\rWhy R?\rSince R is free and open source, it is a program and skill that can be carried with you across many institutions and jobs and is for many, the single solution for statistical analysis, graphing and even GIS/spatial analysis. Programs like JMP, SPSS and ARCGIS cost 100s if not 1000s of dollars and are quickly outdated by new versions.\nHowever, the biggest uses of R come from its sharability and openness. Collaborating and sharing data analysis with R requires only the script and raw data. All data manipulations are done within R, requiring no editing or manipulating of your raw excel data.\n\rR Studio\rThe R Studio Environment\n\rR studio “reskins” the standard R environment, giving space for script writing, help, graphics output and tracking of data files. Due to the ease of working in R studio, thats what we will be using. R studio can provide an array of functions from statistical analysis and graphing, GIS/spatial analysis, presentations, document preparation (all of these tutorials are written in R) and even novel functions like interacive graphs and tweeting.\n\rLayout\rR studio is separated into 4 panels:\n\rThe top-left panel (blue) is the editor (or script window) where you can view and write your R script. This is a saveable document of code. Running code is as simple as Ctrl+Enter on a line of code or pressing the run button in the top-right of this window.\n\rThe bottom-left (red) is the console. This is the standard R environment where you can run code directly, or view the output of your script as you run it.\n\rThe top-right (green) is your workspace. This lists each “object” as you create them through your analyses. Clicking a data-frame object will allow you to view it.\n\rThe bottom-left (black) has lists of files and packages as well as the help window (quickly access by typing ? before any command) and plots which shows any graphical output.\n\r\rNow we have an idea of what R is, it is time to install R \u0026amp; R Studio onto your computer.\nInstall Instructions\n1. Click Here to visit the R webpage and select one of the Australian mirrors to download (CSIRO, University of Melbourne etc.)\n2. Select your version (Windows or Mac), then download the base subdirectory\n3. Once installed, visit R studio to download R studio desktop.\n Once both of those are installed, you can now proceed to open up Rstudio\n\r\r"
},
{
	"uri": "/data-exploration-and-manipulation/",
	"title": "Data Exploration and Manipulation",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Basics Discover what this Hugo theme is all about and the core-concepts behind it.\n"
},
{
	"uri": "/introduction-to-r/02_setting-up-your-workspace/",
	"title": "Setting up your workspace",
	"tags": [],
	"description": "",
	"content": "There are very quick ways to open R and begin coding, however, having an organised, well-structured working directory in your computer can save you hours of hassle and make your code much easier to share. As biology and data science are becoming increasingly complex many are turning to computer intensive, coding based software (like you!). With this movement in data science and open access, having our code reproducible, transparent and understandable is key. So why not start off like that.\nThe first part of this tutorial follows many practices outlined in the fantastic “Guide to Reproducible Code in Ecology and Evolution” from the British Ecological Society. I strongly recommend reading this at some stage.\n File system\rBefore we jump into R, we are going to create a clean and managable folder system.\rCreate a new folder in a location of your choosing (e.g. My Documents or Desktop) called R-tutorials\n This can be named anything you like, but try to keep it relevant and understandable (for future you).\nIn this new folder, create a series of new folders called:\n- data\n- doc\n- figs\n- output\n- R\n Here is the basic outline for these folders:\n\r\rThe data folder if where you store your raw/input data\r\r\rThe doc folder is where you store the manuscript for the project\r\r\rThe figs folder is where all of your figures will be stored from the analyses\r\r\rThe output folder is where you keep any intermediate datasets generated by your analysis, result reports etc.\r\r\rThe R folder is pretty self-explanatory but it is where we will store all of our R scripts, notebooks etc.\r\r\rNow, let’s move on to the next step.\n\r"
},
{
	"uri": "/introduction-to-r/03_creating-a-project-and-notebook/",
	"title": "Creating a project and notebook",
	"tags": [],
	"description": "",
	"content": "Now that we have our folder setup, lets move into R studio and create our project.\nThe first step when opening a new R studio environment is creating a script or notebook for working in. Scripts are basic text files where all code is executable. Writing non-code in a script requires the use of #’s (which can look messy and confusing) like so:\nread.csv(\u0026quot;datafile.csv\u0026quot;) # this code reads a csv (data) file into R. The command read.csv requires brackets with the filepath to the file in quotations. # in this code, none of the #\u0026#39;s will run. so if I # the read.csv command, it will not run. like so:\r# read.csv(\u0026quot;datafile.csv\u0026quot;)\rA whole document of the above example can get messy and hard to understand.\nIn a notebook, we separate normal text from code by inserting “code chunks” (insert \u0026gt; R in the top right of the window). Chunks are specialised areas in the notebook for code only.\rChunks separate code from text, making it easier to write notes and read. These tutorials have been written in a notebook.\n To create a notebook or script, simply use the pulldown menus file \u0026gt; new file and select either a script or notebook one. Then save the document by hitting the disk icon (or file \u0026gt; save) R studio will prompt you to install some packages to use a notebook. Do so and then read the text in the notebook then clear everything below the “output:” — area. As stated above, click the insert pulldown menu in the script window and click R to insert a code chunk. All code in a notebook must be written in a chunk   IMPORTANT!\r\rWherever you save the notebook/script will become the default “directory”. R will look here for files first. If you want to set your working directory elsewhere, use the below code.\n\rI advise creating a folder and saving the notebook to the folder. All datafiles for these pracs can be placed in the same folder as your script/notebook. This will simplify the process of reading in data.\r\r# Only do this if you want your notebook/script in a different folder from data\rsetwd(\u0026quot;Drive:/Folder1/Folder2\u0026quot;)\r# insert your folders path in the brackets\r# this will tell R to look here for files and \u0026quot;generally\u0026quot; save things here as well.\r# e.g. C:/Users/Mitch/Documents/R/\r\rAfter writing your code, you can click run, run selected line(s), run current chunk or press Ctrl + Enter on the line your cursor is on\n\rGet used to this, you will do this ALOT\n\r"
},
{
	"uri": "/introduction-to-r/04_importing-data/",
	"title": "Importing Data",
	"tags": [],
	"description": "",
	"content": "Now that we have successfully have a notebook and appropriate working directory, we can start to read in data.\nThe first thing with R is that working with normal excel files is quite difficult. So we always work with comma separated values or .CSV files. When saving an excel sheet, just save as and select .csv (comma delimited) as the file type. note: .csv’s can only save a single sheet, not the whole excel workbook\nWhen saving, Excel will inform you that some features may not save with a .csv. This shouldn’t be a problem for you, but read these to make sure.\nImporting our data into R allows us to not only analyse and graph the data, but do manipulations, like create new columns using formulae, rearranging, rename and even removing columns \u0026amp; rows without modifying our original data file. This is incredibly useful to maintain the original raw data, allowing you to share the data and R script with collaborators across a wide range of platforms.\nFor these tutorials, all data will be csv files (unless otherwise specified).\nDownload the “weeds” and “insecticide” datasets from the Datasets tab and save them to your project folder.\n Use the following code within a chunk to enter your data into R:\nread.csv(\u0026quot;weeds.csv\u0026quot;)\rThe file needs to be in your set working directory. If it is not, you need the full filepath. You can skip the working directory step by using the full file path. e.g. “C:/Users/Mitch/Documents/R/weeds.csv”\nThis can be copied from file explorer, but make sure the slash’s are / and not\n This alone will just read the data in its basic form into R. If we want to call on this later we need to save the datafile or “data frame” to a variable of our choosing. By saving different functions in R to a variable/object we reduce the amount of work we need to do later. Instead of typing “group_data_2018_complete.csv” everytime, we can instead just call it “data”, “X” or even “skittles” and type that when we refer to the data.\nI personally would choose something a little more descriptive than just “data”, as it can get confusing when working with multiple data sets\nAssigning a function in R to a variable is one of the most important aspects of coding in R.\n This is done by the following:\nweeds \u0026lt;- read.csv(\u0026#39;weeds.csv\u0026#39;)\r# we simply direct our command, read.csv() to our variable name using an arrow of \u0026lt; and -\r# alternatively, \u0026#39;alt\u0026#39; + \u0026#39;-\u0026#39; is the shortcut for this. \rR will automatically assume that the first row are our column headings. The read.csv() command has this by default. If you want to change this, simply include the header=FALSE argument (like below). Arguments are anything within the brackets of a command that can be added to the command. Even stating your filename in the read.csv is an “argument”\nSimilarly, read.csv() defaults its own row numbers (like excel). You can change this by adding row.names= to the command. If you add =1 it will take the first column as your row numbers/names.\nweeds \u0026lt;- read.csv(\u0026#39;weeds.csv\u0026#39;, header=FALSE) # this will stop the automatic placement of your first row as your column headers. The default for this is TRUE\rweeds \u0026lt;- read.csv(\u0026#39;weeds.csv\u0026#39;, row.names=1) # This places your first column as your row names. Change the number to make a different column your row names\r# This is useful to place site names/numbers as your row numbers. It is basically required when trying to do multivariate (PRIMER) analysis in R.\r# You can combine the two just by adding a comma between them, like so:\rweeds \u0026lt;- read.csv(\u0026#39;weeds.csv\u0026#39;, header=TRUE, row.names=1)\r# we want the first row to be our column names, so we say TRUE for header. # You dont need to do this, as its an assumed default by R...but its good practice\r# For these workshops we will be using R\u0026#39;s default row numbering. So just overwrite your read.csv() without the row.names\rweeds \u0026lt;- read.csv(\u0026#39;weeds.csv\u0026#39;, header=TRUE)\rOnce your data is imported into R and saved as an object, either click the object in the Workspace/environment or use View(weeds)\nWhat is the argument of read.csv() I would need to use to make the sites column my row names?\n ## sites type\r## 1 WAM5 plan\r## 2 WBT1 iso\r## 3 WBT2 rem\r## 4 WBT4 rip\r## 5 WCS2 rip\r## 6 WCS3 iso\r  Answer   row.names=1\nfull command: read.csv(\u0026quot;sitedata.csv\u0026quot;, row.names=1)\n "
},
{
	"uri": "/statistical-analysis/",
	"title": "Statistical Analysis",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Content Find out how to create and organize your content quickly and intuitively.\n"
},
{
	"uri": "/data-exploration-and-manipulation/data-manipulation/grammar-of-graphics/",
	"title": "The Grammer of Graphics - Plotting your data with ggplot!",
	"tags": ["ggplot"],
	"description": "",
	"content": "\rResources\rThe Grammar of ggplot\rBasic plots\r\rCustomising your graph\rGrids and Background\rAxis Lines\rPanel lines/grids\rLabels\rA Proper example\r\rPlotting our analysed data\rWeeds (ANOVA bar graph)\rTadpoles (linear regression)\rNest Dataset (Logistic Regression/GLM)\r\r\r\rBy now you should be fairly familiar with the R environment and decently familiar with tidyverse. You should be able to perform basic data manipulations, analyses and in general, understand the general concepts of working with data in R.\nTo me personally, graphing is the funnest part of statistics. Being able to visually communicate your findings in new and interesting ways is exciting and a joy when you have so many ways to customise your message. Data analysis is important and useful, but the fun part is definately graphing.\nFor this module, we will be working soley within the ggplot graphing environment. Before we start, I should mention - R does have its own plotting functions which are powerful and very useful.\nGGPLOT is just better :)\nTo start, we will cover the bases of what ggplot is and how to build basic graphs with some free data built into R.\nResources\rHere are a few websites and useful places for ggplot graphing help. Its great to see examples of graphs along with code to help.\n\rGGPLOT CHEATSHEET - Seriously, this is amazing. There are a few of these on R studios’ website for a bunch of packages. I have a few of these printed on the wall of my office. Additonally, many of these can be accessed in the Help toolbar next to tools\rGGPLOT Reference Site - The official ggplot help site\n\rData Carpentry’s ggplot guide\n\rR Graphics Cookbook - Useful guides for graphing\r\rWrite Ok in the following box to continue:\n{1:SHORTANSWER:=Ok}\n\rThe Grammar of ggplot\rggplot is one of the many packages installed with tidyverse, but is important package on its own, that can be installed by itself library(ggplot2).\nGGplot was built as a way to implement Leland Wilkinson’s “Grammar of Graphics”. The gammar of graphics broke up data visualisation into semantic components such as scales, layers and various aesthetic features. GGplot is a implementation of this scheme into the R environment.and its crazy powerful.\nFirst, make sure ggplot2 or tidyverse is installed and loaded using the library() command.\nOnce we have that loaded into our environment, we need to create our first plot window following this basic structure.\nplot1 \u0026lt;- ggplot(data, aes(x = variable, y = variable)) +\rgeom_graph.type()\rplot1 # to view our object\rWe begin by creating a new object/variable of our choosing like almost everything else we do. We then use the ggplot() function to build a blank plot window.\nThe aes argument specifies what variables we want to plot in our blank window. aes stands for aesthetics, which is slightly confusing because it relates to what data we are displaying.not how we display it.\nThe + geom_graph.type() will be the type of graph you want to display. the commonly used examples are:\n\rboxplot - + geom_boxplot()\rbarplot - + geom_bar()\rscatterplot - + geom_point()\r\rGeom stands for geometric, and tells R the type of geometric shape you want the data to form. You will need () closed brackets at the end of the geom_type() regardless of whether you choose to put anything inside them.\nThe next important thing is the use of additive building in ggplot. As you can see in the example, we use a + sign before adding the geom_type we want. Everything in ggplot uses these additive steps before each function. This allows you to add and change things on your graph step by step, building and viewing your graph as you go. This will make more sense as we go.\nWrite Ok in the following box to continue:\r{1:SHORTANSWER:=Ok}\nBasic plots\rTo start, we will use the iris dataset that is built into tidyverse/ggplot2. To view the dataset, use the View() command like so:\nView(iris)\rOnce we have this, let’s setup a basic boxplot of some of the features of iris.\nThe iris dataset is built into tidyverse/ggplot2. The dataset is a famous dataset by Edgar Anderson that gives the sepal length, width and petal length and width for three species of iris (n=50).\nWe are going to begin by plotting the sepal length for each species in a basic boxplot.\niris.box \u0026lt;- ggplot(iris, aes(x=Species,y=Sepal.Length)) +\rgeom_boxplot()\riris.box # We have to run a line with the name of the plot object to view the graph. \rSo far, pretty straight forward.\nYou will notice I saved the ggplot() graph to an object called iris.box. Because I saved the plot to an object, I have to run the object name to view the plot. This is identical to using the command print(iris.box).\nNow let’s look at some others, such as a histogram.\niris.hist \u0026lt;- ggplot(iris, aes(x=Sepal.Length)) +\rgeom_histogram()\riris.hist\rThat’s pretty ugly, but a simple addition of binwidth=“value” will fix that. Binwidth refers to the width of each bin, or bar, in the frequency histogram. A bin width of 0.5 means each bar of the histogram will be equal to 0.5 on the x axis (e.g. 4, 4.5, 5, 5.5 etc).\niris.hist \u0026lt;- ggplot(iris, aes(x=Sepal.Length)) +\rgeom_histogram(binwidth = 0.5)\riris.hist\rNow let’s look at a scatterplot.\niris.scatter \u0026lt;- ggplot(iris, aes(x=Sepal.Length,y=Petal.Length)) + geom_point()\riris.scatter\rThe cool thing we can do with scatterplots is colour the points by a categorical feature such as Species. This is done by adding colour = “categorical variable name” in the aes brackets of the ggplot() command.\niris.scatter \u0026lt;- ggplot(iris, aes(x=Sepal.Length, y=Petal.Length, colour=Species)) +\rgeom_point()\riris.scatter\rMuch better. And it even adds a legend for us.\nNow we have this basic setup, we can start adding things to our graph. Due to the immense amount of customisations for our graphs, I will break these down in to sections as much as possible and explain as I go. We will work with the iris dataset for a while before moving to our analysed datasets.\nWrite Ok in the following box to continue:\r{1:SHORTANSWER:=Ok}\n\r\rCustomising your graph\r###Themes \u0026amp; Axis\nThe easiest way to quickly modify your graph is to add one of the preset theme() commands. I will add each of them to the graph which will replace the previous theme.\nWe can simply add items to our current graph object by adding the + sign. Keep in mind that if you dont “resave” it to the object, it wont stick around. If you want to keep a theme, either add it into the original ggplot command, or save it to the same or a new object.\niris.scatter + theme_bw()\riris.scatter + theme_classic()\riris.scatter + theme_dark() \riris.scatter + theme_gray() # The default ggplot theme\riris.scatter + theme_minimal()\riris.scatter + theme_light()\riris.scatter + theme_linedraw()\riris.scatter + theme_void()\rPretty significant changes to the graphs appearance with little effort.\nOf course, we can modify all the individual components of a theme without using one of the presets.\nThe best way to show this would be to look at the ?theme (help) window for this one. The general format for this is as follows.\niris.scatter \u0026lt;- ggplot(iris, aes(x=Sepal.Length, y=Petal.Length, colour=Species)) +\rgeom_point() +\rtheme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = \u0026quot;black\u0026quot;)) + theme(axis.text.x = element_text(colour = \u0026quot;black\u0026quot;, size = 12)) + theme(axis.text.y = element_text(colour = \u0026quot;black\u0026quot;, size = 12)) +\rtheme(plot.title = element_text(color=\u0026quot;blue\u0026quot;, size=12))\riris.scatter\rWithin the theme() command, we simply call the feature we want to change, followed by how we want to change it.\rFor the panel grids and background, we call element_blank() to make it blank. Changing that to element_line() for the grids, and element_rect() for the background would change them to lines and rectangle, respectively. From there we could pick colour, size etc.\nIn the axis.text lines, we are setting the text colour to “black” and the font size to 14.\nNow obviously, this is pretty daunting. But, you dont have to specify everything. You can very easily use one of the above preset themes (e.g. theme_minimal) and change one or two other things, such as axis line colour etc.\nTo save yourself writing all of the above theme() commands everytime you do a graph, you can save your favourite custom settings to its own object and add that to your graphs. Like so:\nsimpletheme \u0026lt;- theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = \u0026quot;black\u0026quot;), axis.text.x = element_text(colour = \u0026quot;black\u0026quot;, size = 12), axis.text.y = element_text(colour = \u0026quot;black\u0026quot;, size = 12),plot.title = element_text(color=\u0026quot;blue\u0026quot;, size=12))\r# We simply direct all of our theme arguments to an object\riris.scatter \u0026lt;- iris.scatter + simpletheme # then, just add that object to our graph\rFor example, let’s add those custom theme settings to our boxplot we generated earlier.\niris.box + simpletheme\rOk, so that was alot of information that probably doesn’t make sense, so let’s break that down into its components.\nWrite Ok in the following box to continue:\r{1:SHORTANSWER:=Ok}\nGrids and Background\rThe plot and legend background colours can be changed using the following:\n\rpanel.background = element_rect(insert changes here) - This changes the background of the main plot itself. We need element_rect() as it is a rectangle geometric object.\n\rlegend.background = element_rect(insert changes here) - This will change the main area of the legend.\n\rlegend.key = element_rect(insert changes here) - This will change the small boxes that each of the factors levels are identified with.\r\rFor all arguments, you can replace the element_rect(), element_line() etc. with element_blank() to remove it.\nWithin each of the element_rect() we can change various things. The most common ones are:\n\rfill = “colour” - This will change the overall colour of the object.\rcolour = “colour” - This will change the outline of the rectangle.\rsize = number - This will change the size/thickness of font and lines.\r\rEach of the “colour” arguments can be a specified a number of ways. The most common way is using one of the MANY predefined colours within R. A quick run down of these can be found HERE. For any of these, just put the name as it is spelt in that guide in quotations.\niris.scatter + theme(panel.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;red\u0026quot;), legend.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;yellow\u0026quot;, size=1), legend.key = element_rect(fill = \u0026quot;gray50\u0026quot;, colour = \u0026quot;green\u0026quot;, size = 0.5)) \r\rAxis Lines\rTo change the axis lines and ticks (lines above each number on an axis) use the following.\n\raxis.line = element_line(insert changes here) - This will change both axes lines.\n\raxis.line.x = element_line(insert changes here) - This will change just the x axis.\n\rais.line.y = element_line(insert changes here) - This will change just the y axis.\n\raxis.ticks = element_line(insert changes here) - Change both axes ticks. Use the .x or .y to change just one axis at a time.\n\raxis.ticks.length = element_line(insert changes here) - Change the length of the axes ticks.\n\raxis.text = element_text(insert changes here) - Change the text on the axes TICKS. Use .x or .y to change just one.\n\raxis.title = element_text(insert changes here) - Change the text on the axes LABELS/TITLES. Use .x or .y to change just one.\n\rplot.title = element_text(insert changes here) - Change the plot title.\r\rJust use the colour and size arguments where appropriate. I am going to add these changes as a separate theme() command, but they can be added in the same command as last time.\niris.scatter + theme(panel.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;red\u0026quot;), legend.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;yellow\u0026quot;, size=1), legend.key = element_rect(fill = \u0026quot;gray50\u0026quot;, colour = \u0026quot;green\u0026quot;, size = 0.5)) +\rtheme(axis.line.x = element_line(colour = \u0026quot;skyblue\u0026quot;, size=2), axis.line.y = element_line(colour=\u0026quot;deeppink\u0026quot;, size = 2), axis.title.x = element_text(colour=\u0026quot;forestgreen\u0026quot;, size=14), axis.title.y = element_text(colour = \u0026quot;gold\u0026quot;, size=8), axis.ticks = element_blank())\rBeautiful, isn’t it?\nNow you may have notice the size command acts differently for line and text. For line it is based on a multiplier of the original. So a 2 will be two times its normal size. Element_text() has size as a font size. So 2 would be tiny and equivalent to 2pt font.\rAlternatively, you can use size = rel(number) to scale the text relative to base R’s plotting size.\n\rPanel lines/grids\rSo far, our graph does not have the original ggplot grid lines because we removed them in our original graph. Before we start changing these, let’s save our beautiful masterpiece to an object/variable to simplify the theme() changing.\niris.scatter \u0026lt;- iris.scatter + theme(panel.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;red\u0026quot;), legend.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;yellow\u0026quot;, size=1), legend.key = element_rect(fill = \u0026quot;gray50\u0026quot;, colour = \u0026quot;green\u0026quot;, size = 0.5)) +\rtheme(axis.line.x = element_line(colour = \u0026quot;skyblue\u0026quot;, size=2), axis.line.y = element_line(colour=\u0026quot;deeppink\u0026quot;, size = 2), axis.title.x = element_text(colour=\u0026quot;forestgreen\u0026quot;, size=14), axis.title.y = element_text(colour = \u0026quot;gold\u0026quot;, size=8), axis.ticks = element_blank())\rTo change the grid lines on your plot, it is done with the following:\n\rpanel.grid.major = element_line(insert changes here) - Changes the major grid lines on the graph. Use .x or .y to change just one.\n\rpanel.grid.minor = element_line(insert changes here) - Changes the minor grid lines on the graph. Use .x or .y to change just one.\r\rAgain, using the same principals of colour and size for these ones.\niris.scatter + theme(panel.grid.major = element_line(colour=\u0026quot;aquamarine\u0026quot;, size=1), panel.grid.minor = element_line(colour=\u0026quot;slategray2\u0026quot;, size=2)) \rJust like we did before, we can make all of these our own custom theme by directing them to an object.\nmasterpiece \u0026lt;- theme(panel.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;red\u0026quot;), legend.background = element_rect(fill=\u0026quot;lavender\u0026quot;, colour=\u0026quot;yellow\u0026quot;, size=1), legend.key = element_rect(fill = \u0026quot;gray50\u0026quot;, colour = \u0026quot;green\u0026quot;, size = 0.5), axis.line.x = element_line(colour = \u0026quot;skyblue\u0026quot;, size=2), axis.line.y = element_line(colour=\u0026quot;deeppink\u0026quot;, size = 2), axis.title.x = element_text(colour=\u0026quot;forestgreen\u0026quot;, size=14), axis.title.y = element_text(colour = \u0026quot;gold\u0026quot;, size=8), axis.ticks = element_blank(), panel.grid.major = element_line(colour=\u0026quot;aquamarine\u0026quot;, size=1), panel.grid.minor = element_line(colour=\u0026quot;slategray2\u0026quot;, size=2))\rNow let’s add that to our boxplot.\niris.box + masterpiece\rA true work of art!\n\rLabels\rIf we want to change the axis labels themselves, this is done using the labs() command.\niris.scatter \u0026lt;- iris.scatter + labs(x = \u0026quot;Sepal Length (cm)\u0026quot;, y = \u0026quot;Petal Length (cm)\u0026quot;)\riris.scatter\rIf we wish to add a title to our plot (not overly common in publications) we can use the following.\niris.scatter \u0026lt;- iris.scatter + labs(title= \u0026quot;Relationship between petal and sepal length\u0026quot;) iris.scatter\r\rA Proper example\r## Setting up the graph environment ##\riris.scatter.proper \u0026lt;- ggplot(iris, aes(x=Sepal.Length, y=Petal.Length, colour=Species, shape=Species)) + geom_point()\r## Making our theme ##\rplottheme \u0026lt;- theme(panel.background = element_rect(fill=\u0026quot;ghostwhite\u0026quot;),\rlegend.background = element_blank(),\rlegend.key = element_rect(fill=\u0026quot;ghostwhite\u0026quot;),\raxis.line = element_line(colour=\u0026quot;black\u0026quot;, size=1),\raxis.ticks = element_blank(),\raxis.title = element_text(colour=\u0026quot;royalblue3\u0026quot;, size=14),\rplot.title = element_text(face=\u0026quot;bold\u0026quot;, colour=\u0026quot;steelblue4\u0026quot;, size=16),\rlegend.title = element_text(colour=\u0026quot;royalblue3\u0026quot;, size=14),\rlegend.text = element_text(face=\u0026quot;italic\u0026quot;, colour=\u0026quot;steelblue4\u0026quot;, size=10),\raxis.text = element_text(colour=\u0026quot;steelblue4\u0026quot;, size=12),\rpanel.grid.major = element_line(colour=\u0026quot;gray80\u0026quot;),\rpanel.grid.minor = element_blank())\r## Applying the theme, adding some labels and changing some colours ##\riris.scatter.proper \u0026lt;- iris.scatter.proper + plottheme +\rlabs(x=\u0026quot;Sepal Length (cm)\u0026quot;, y=\u0026quot;Petal Length (cm)\u0026quot;, title=\u0026quot;Relationship between Sepal Length and Petal Length\u0026quot;) +\rscale_colour_manual(values = c(\u0026quot;mediumorchid1\u0026quot;, \u0026quot;mediumorchid3\u0026quot;, \u0026quot;mediumorchid4\u0026quot;))\r## Displaying our graph ##\riris.scatter.proper\rPretty cool example of changing things around for the “better”. You might notice a few extra things I have changed in this graph.\nIn the aes() section at the start, I introduced the shape command which changes the shape for each level of a factor. Doing this alongside colour= allows us to change the colour and symbol of the points themselves.\nFurther down, I then changed the colour of the points using scale_colour_manual() and adding the colour values for the levels in order. There are many different ways you can do this, but I find this works the best. There are scale_manual commands for fill, group, shape etc.\nIn the theme() section, I covered most things we have done so far but added an additional argument to legend.text and plot.title. This is the face argument which allows us to add italics, bold or others to our text.\nWrite Ok in the following box to continue:\r{1:SHORTANSWER:=Ok}\n\r\rPlotting our analysed data\rHopefully by now, we understand the general principals of ggplot and how to heavily customise the appearance. Now, lets start plotting our analysed data.\nWeeds (ANOVA bar graph)\rOur first data set we analysed was the weeds dataset where we performed a two-factor ANOVA.\nweeds.aov2 \u0026lt;- aov(flowers ~ species * soil, data = weeds)\ranova(weeds.aov2)\r## Analysis of Variance Table\r## ## Response: flowers\r## Df Sum Sq Mean Sq F value Pr(\u0026gt;F) ## species 2 2368.6 1184.31 9.1016 0.0005203 ***\r## soil 1 238.5 238.52 1.8331 0.1830080 ## species:soil 2 155.0 77.52 0.5958 0.5557366 ## Residuals 42 5465.1 130.12 ## ---\r## Signif. codes: 0 \u0026#39;***\u0026#39; 0.001 \u0026#39;**\u0026#39; 0.01 \u0026#39;*\u0026#39; 0.05 \u0026#39;.\u0026#39; 0.1 \u0026#39; \u0026#39; 1\rFrom this, only Species was significant. For this dataset with a continuous Y and categorical X we would plot a bargraph.\nThe best way to generate the bargraph properly, is to use the *summarise()** command to generate our means and standard errors before plotting. We can generate these within the ggplot command, but it can lead to complications.\nweeds.summarise \u0026lt;- weeds %\u0026gt;% group_by(species) %\u0026gt;%\rsummarise(mean = mean(flowers), se=sd(flowers/sqrt(n())))\rThis is a quick way to generate our mean and se for flowers for each species. Now, we can graph our results in a bargraph.\nweeds.col \u0026lt;- ggplot(weeds.summarise, aes(x=species, y=mean, fill=species)) +\rgeom_col()\rweeds.col\rThis will generate a pretty basic graph. You will notice that I used fill instead of colour. If you use colour on a column/bar graph it will only do the outline. Using fill will fill the entire bar according to the species.\nWe used geom_col() to generate a column graph. You can use geom_bar() but it requires a stat = argument. If you use geom_bar() try stat = “identity” to use the numbers in the mean column of our data.\nI would reccomend geom_bar() as it is easier to do errorbars later\nweeds.bar \u0026lt;- ggplot(weeds.summarise, aes(x=species, y=mean, fill=species)) +\rgeom_bar(stat=\u0026quot;identity\u0026quot;)\rweeds.bar\rRegardless of what way you graph this, they look the same. For now, let’s work with the geom_col(). Let’s fix up the graph as much as we want, until we are happy. To demonstrate this, I will produce the graph without showing the code and you can customise your graph how you see fit.\nSo, now we have our graph in a “nicer” format, we can see that there are some cruical points of information missing from this graph. Most notably, the errorbars and letters or some other notation that denotes statistical differences between the levels (Tukeys results).\nNote: To remove the legend like I have, include the show.legend argument in your geom_bar() command and set it to false. e.g. geom_bar(stat=“identity”, show.legend=F)\nTo add the error bars, we use the following command\nweeds.bar \u0026lt;- weeds.bar + geom_errorbar(aes(ymin = mean-se, ymax = mean+se), width=0.5)\rweeds.bar\rThis is suprisingly simple. All we do is specify the aesthetic (aes) where we compute our minimum and maximum y values for our bars as our mean column +/- our standard error column. The width argument is how wide we want our error bars to be. A size argument can be added to make the lines thicker if needed. Try modifying the value on width to see how it works, 0.9 is the default.\nAdding Tukeys test results is simple but slightly tedious once we have the results.\nlibrary(agricolae)\rHSD.test(weeds.aov2, \u0026quot;species\u0026quot;, console=TRUE)\r## ## Study: weeds.aov2 ~ \u0026quot;species\u0026quot;\r## ## HSD Test for flowers ## ## Mean Square Error: 130.122 ## ## species, means\r## ## flowers std r Min Max\r## Coprosma 24.1250 11.13478 16 13 52\r## Olearia 36.7500 12.08580 16 16 55\r## Pultenaea 40.5625 10.97858 16 20 57\r## ## Alpha: 0.05 ; DF Error: 42 ## Critical Value of Studentized Range: 3.435823 ## ## Minimun Significant Difference: 9.798198 ## ## Treatments with the same letter are not significantly different.\r## ## flowers groups\r## Pultenaea 40.5625 a\r## Olearia 36.7500 a\r## Coprosma 24.1250 b\rAccording to the tukeys results, Coprosma is significantly different from the others. So we will label it A and the others B.\nweeds.bar \u0026lt;- weeds.bar + geom_text(label = c(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;B\u0026quot;), aes(y = c(28.5, 41, 44.5), x = species), size = 6)\r# try including the geom_text() in your original weeds.bar code. # if you keep adding it like this, the letters will stack and it will be a mess.\rweeds.bar\rAdding the letters is done through geom_text(). We need to specify the labels (in order) along with the aesthetic coordinates on the x and y axis. The X axis we can direct it to our original x axis data (species) and it will sit in the centre of the column. The Y coordinates are the location on the Y axis the text should sit.\nThis requires alot of playing around to get them correct so I would advise doing this when you first setup the graph. If you don’t, and keep re-running the geom_text() commands, you can end up with multiple letters.\nThere is an alternative to setting the coordinates manually.\n# Note: I have reset my weeds.bar to remove the previous letters posthoc \u0026lt;- HSD.test(weeds.aov2, \u0026quot;species\u0026quot;, console=TRUE)\r## ## Study: weeds.aov2 ~ \u0026quot;species\u0026quot;\r## ## HSD Test for flowers ## ## Mean Square Error: 130.122 ## ## species, means\r## ## flowers std r Min Max\r## Coprosma 24.1250 11.13478 16 13 52\r## Olearia 36.7500 12.08580 16 16 55\r## Pultenaea 40.5625 10.97858 16 20 57\r## ## Alpha: 0.05 ; DF Error: 42 ## Critical Value of Studentized Range: 3.435823 ## ## Minimun Significant Difference: 9.798198 ## ## Treatments with the same letter are not significantly different.\r## ## flowers groups\r## Pultenaea 40.5625 a\r## Olearia 36.7500 a\r## Coprosma 24.1250 b\r# we save this so we can call on it to do our letters. This will also work for a normal \u0026quot;non-agricolae\u0026quot; tukeys, but will be called something different in the dataframe\rweeds.bar \u0026lt;- weeds.bar + geom_text(label = posthoc$groups$groups, aes(y=mean+se, x=species), vjust=-0.5, size=6) + ylim(0, 50)\rweeds.bar\rIn this example, we pull the lettering from our posthoc tukeys test after saving it to a dataframe. We then specify our Y coordinates as the top of our error bar and use the vjust argument to move it slightly above the bar. This means we also had to change our ylim to display the last letter, which got cut off.\nThis seems like alot more work, but when you have a lot more bars…you will thank me\nThats the general process for setting up a column graph for ANOVA data. It can take some time, but we get alot of freedom in how we present this.\nOnce we are satisfied with our final product, we can save it as a image file to our current working directory. Simply plot the graph again, by calling the object name, then use the ggsave() command like so.\nweeds.bar #producing the graph again\rggsave(\u0026quot;weeds_bargraph.jpeg\u0026quot;) # specify the name and filetype (.jpeg, .png etc.). You can also specify the width and heigh of your final image\rggsave() will save the last plot you produced into your current working directory. You need to specify the name (in my case “weeds_bargraph”) and the filetype (.jpeg in my example). By default, it should save a 7 cm x 7cm image. If you want to change that, use the width = or height = arguments, like so. For higher resolution images, try .png or .tif\nggsave(\u0026quot;weeds_bargraph.jpeg\u0026quot;, width=9, height=7)\rI wanted a slightly wider figure but it’s personal preference.\nPlotting multiple columns\rIn the last example, we plotted a single column graph. To plot multiple columns, for example a soil by species interaction, is quite simple.\nweeds.summarise2 \u0026lt;- weeds %\u0026gt;% group_by(species, soil) %\u0026gt;%\rsummarise(mean = mean(flowers), se=sd(flowers/sqrt(n())))\rweeds.bar2 \u0026lt;- ggplot(weeds.summarise2, aes(x=soil, y=mean, fill=species)) +\rgeom_bar(stat=\u0026quot;identity\u0026quot;)\rweeds.bar2\rSimply specifying one column from our dataset on the x axis, and filling/colouring by another will plot both of the data. However, you can see the bar graph has stacked the species ontop of one another. To fix this, include the position=position_dodge() argument in your geom_bar(), like so.\nweeds.bar2 \u0026lt;- ggplot(weeds.summarise2, aes(x=soil, y=mean, fill=species)) + geom_bar(stat=\u0026quot;identity\u0026quot;, position=position_dodge())\rweeds.bar2\rNOTE: You will need to include the position=position_dodge() in your errorbar code. I have had a lot of issues with dodged bargraphs and error bars…so it can get a little finicky.\nWrite Ok in the following box to continue:\r{1:SHORTANSWER:=Ok}\n\r\rTadpoles (linear regression)\rIn our second dataset, we analysed tadpole abundance in different sized ponds using a linear model/regression.\ntadpoles.lm \u0026lt;- lm(abundance ~ pondsize, data = tadpoles)\rsummary(tadpoles.lm)\r## ## Call:\r## lm(formula = abundance ~ pondsize, data = tadpoles)\r## ## Residuals:\r## Min 1Q Median 3Q Max ## -73.546 -29.752 -8.026 37.978 77.652 ## ## Coefficients:\r## Estimate Std. Error t value Pr(\u0026gt;|t|) ## (Intercept) 23.8251 25.8455 0.922 0.36662 ## pondsize 1.7261 0.5182 3.331 0.00303 **\r## ---\r## Signif. codes: 0 \u0026#39;***\u0026#39; 0.001 \u0026#39;**\u0026#39; 0.01 \u0026#39;*\u0026#39; 0.05 \u0026#39;.\u0026#39; 0.1 \u0026#39; \u0026#39; 1\r## ## Residual standard error: 49.42 on 22 degrees of freedom\r## Multiple R-squared: 0.3352, Adjusted R-squared: 0.305 ## F-statistic: 11.09 on 1 and 22 DF, p-value: 0.003032\rFor this, we will be setting up a scatter plot (geom_point) of our points and then adding the line separately.\ntadpoles.scatter \u0026lt;- ggplot(tadpoles, aes(x=pondsize, y=abundance)) +\rgeom_point()\rtadpoles.scatter\rThats our basic scatter plot. Thankfully, doing a simple linear regression on ggplot is super simple.\ntadpoles.scatter + stat_smooth(method = lm)\rThe stat_smooth() will produce a line of best fit, along with the confidence intervals based on the method of fit we choose. If we choose linear model (lm) it will construct a linear model of our Y variable by the X variable.\nIf you dont want the shaded confidence intervals, simply add the argument, se=FALSE within the brackets.\ntadpoles.scatter \u0026lt;- ggplot(tadpoles, aes(x=pondsize, y=abundance)) +\rgeom_point() +\rstat_smooth(method=lm, se=FALSE)\rtadpoles.scatter\rWe can also add multiple lines, based on a factor using the colour argument.\ntadpoles.scatter2 \u0026lt;- ggplot(tadpoles, aes(x=pondsize, y=abundance, colour=reeds)) +\rgeom_point() +\rstat_smooth(method=lm, se=FALSE)\rtadpoles.scatter2\rNotice that they stop within the range of the points. To extend these use fullrange=TRUE. Use this cautiously, as it extrapolates the current relationship past your datapoints.\ntadpoles.scatter2 \u0026lt;- ggplot(tadpoles, aes(x=pondsize, y=abundance, colour=reeds)) +\rgeom_point() +\rstat_smooth(method=lm, se=FALSE, fullrange=TRUE)\rtadpoles.scatter2\rWrite Ok in the following box to continue:\r{1:SHORTANSWER:=Ok}\n\rNest Dataset (Logistic Regression/GLM)\rIn our third dataset, we analysed the nest predation dataset using a generalised linear model with a binomial distribution, also known as a Logistic Regression.\nIn this scenario, our data is measuring whether a nest was attacked or not in areas of different shrubcover. When we analyse this using a GLM, it is calculating the probability of a nest being attacked, given different values of shrubcover. As such, we need to plot this in a similar manner.\nFirst let’s demonstrate what happens when we don’t take the binomial distribution into account.\nnest.wrong \u0026lt;- ggplot(nest, aes(x=shrubcover, y=nestattacked)) + geom_point()\rnest.wrong\rNotice how it has plotted the points at either 0 or 1 for each of the corresponding shrubcover values. This does not tell us anything about the likelihood of a nest being attacked given a value of shrubcover.\nThere are multiple methods for producing this plot. The one we will be using generates the relationship between our variables in the code itself.\nnest.smooth \u0026lt;- ggplot(nest,aes(x=shrubcover, y=nestattacked)) +\rgeom_smooth(method = glm, method.args= list(family=\u0026quot;binomial\u0026quot;))\rnest.smooth\rThis method utilises the geom_smooth() function we were using for our linear model. This time we specify the glm relationship in the method argument, instead of lm. We also need to include a second argument called method.args which stands for method arguments, or, additional arguments for the method we have specified. We need to include this so we can inform our code that our distribution (family) is binomial. By including this, we produce our probability curve\nWe can also choose, much like our linear regression example, to remove our standard error/confidence intervals by using the se=FALSE argument rather than the default se=TRUE.\nnest.smooth \u0026lt;- ggplot(nest,aes(x=shrubcover, y=nestattacked)) +\rgeom_smooth(method = glm, method.args= list(family=\u0026quot;binomial\u0026quot;), se=FALSE)\rnest.smooth\rThis is not necassarily “the best” method but it is by far the easiest.\nWrite Ok in the following box to continue:\n{1:SHORTANSWER:=Ok}\n\r\r"
},
{
	"uri": "/the-grammar-of-graphics/",
	"title": "The Grammar of Graphics",
	"tags": [],
	"description": "",
	"content": "Hugo uses Markdown for its simple content format. However, there are a lot of things that Markdown doesn’t support well. You could use pure HTML to expand possibilities.\nBut this happens to be a bad idea. Everyone uses Markdown because it\u0026rsquo;s pure and simple to read even non-rendered. You should avoid HTML to keep it as simple as possible.\nTo avoid this limitations, Hugo created shortcodes. A shortcode is a simple snippet inside a page.\nHugo-theme-learn provides multiple shortcodes on top of existing ones.\n "
},
{
	"uri": "/datasets/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "  Data Sets   insecticide.csv  (0 ko)   weeds.csv  (1 ko)    "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/ggplot/",
	"title": "Ggplot",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/r/",
	"title": "R",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "R Statistics for Ecologists",
	"tags": [],
	"description": "",
	"content": " Ecostatistics "
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]